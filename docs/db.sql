-- https://vivasart.com/en/blog/grouping-data-in-supabase-a-beginners-guide-with-examples
-- view
create view movements_view as
  select
    m.id,
    m.number,
    m.moment,
    m.movement_type,
    m.category_id,
    c.name as category,
    m.concept,
    m.budget,
    m.amount,
    m.balance,
    m.created_at,
    m.updated_at,
    m.deleted_at
  from movements m
  inner join categories c
    on m.category_id = c.id;

--select * from movements_view
-- DROP VIEW IF EXISTS movements_view;

-- view
  -- view
create or replace view movements_by_mont_of_year_view as
  select
    movement_type,
    SUM(amount) as amount_tot,
    to_char(date(moment), 'YYYY') as year,
    to_char(date(moment), 'MM') as mm,
    trim(to_char(date(moment), 'Month')) as month
  from movements 
  group by movement_type, year, mm, month 
  order by year, mm, month;

create or replace view movements_type_and_category_by_mont_of_year_view as
  select
    movement_type,
    category,
    SUM(amount) as amount_tot,
    to_char(date(moment), 'YYYY') as year,
    to_char(date(moment), 'MM') as mm,
    trim(to_char(date(moment), 'Month')) as month
  from movements_view 
  group by movement_type, year, mm, month, category 
  order by year, mm, month, movement_type, category;
  


/* TODO VIEW

  
  select
    movement_type,
    category,
    SUM(amount) as amount_tot,
    to_char(date(moment), 'YYYY') as year
  from movements_view 
  group by movement_type, year, category 
  order by year, movement_type, category;

  select
    movement_type,
    SUM(amount) as amount_tot,
    to_char(date(moment), 'YYYY') as year
  from movements 
  group by movement_type, year
  order by year;
  
  */

--trigger
create or replace function movements_generate_number()
  returns trigger
  language plpgsql
as $$
begin
  new.number:=to_char(current_date, 'yymm')
    || new.type::int::character varying
    || lpad(
      (select count(*) + 1
		    from movements
			  where to_char(date, 'YYMM') = to_char(current_date, 'yymm'))::character varying,5,'0'
		  );

    return new;
end;
$$;
            
create trigger movement_generate_number
  before insert on movements
  for each row
execute function movements_generate_number();

--view
create or replace view movements_view AS
  select
    m.id,
    number,
    date,
    case
      when m.type = true then 'Income' 
      when m.type = false then 'Expenses' 
    end as movement_type,
    c.name as category,
    concept,
    budget,
    amount,
    to_char(date, 'mm') as month
  from movements m
    inner join categories c on m.category_id = c.id;



    --cursor
   --date timestamp with time zone,
-- Use DROP FUNCTION movements_with_balances(integer,character varying)
-- create or replace function movements_with_balances( yyyy integer, mm character varying ) returns table (
create or replace function movements_with_balances() returns table (

    id bigint,
    number character varying,
    moment timestamp with time zone,
    movement_type boolean,
    category character varying,
    concept character varying,
    budget double precision,
    amount double precision,
    balance double precision
) as $$

DECLARE
    accumulated_balance double precision := 0;
    record RECORD;
BEGIN 

    FOR record IN
        SELECT mv.id, mv.number, mv.moment, mv.movement_type, mv.category, mv.concept, mv.budget, mv.amount 
        FROM  movements_view as mv
        --WHERE to_char(mv.moment, 'yyyy')::integer = yyyy and to_char(mv.moment, 'mm') = mm

        ORDER BY id
    LOOP
        IF record.movement_type=true THEN
            accumulated_balance := accumulated_balance + record.amount;
        ELSEIF record.movement_type=false THEN
            accumulated_balance := accumulated_balance - record.amount;
        END IF;

        RETURN QUERY SELECT
            record.id,
            record.number,
            record.moment,
            record.movement_type,
            record.category,
            record.concept,
            record.budget,
            record.amount,
            accumulated_balance;

    END LOOP;
    RETURN;
END;
$$ language plpgsql;

-- select * from movements_with_balances()
-- select * from movements_with_balances(2024, '11')



--movements
create table
  public.movements (
    id bigint generated by default as identity not null,
    number character varying null,
    moment timestamp with time zone not null default now(),
    movement_type boolean not null default false,
    category_id bigint null,
    concept character varying null,
    budget double precision null,
    amount double precision null,
    balance double precision null,
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone not null default now(),
    deleted_at timestamp with time zone default null,
    constraint movements_pkey primary key (id),
    constraint movements_category_id_fkey foreign key (category_id) references categories (id)
  ) tablespace pg_default;

create trigger movement_generate_number before insert on movements for each row
execute function movements_generate_number ();


-- trigger movements_record_the_balance
create or replace function movements_record_the_balance()
  returns trigger
  language plpgsql
as $$
declare
    accumulated_balance DOUBLE PRECISION := 0;
begin

    select COALESCE(MAX(balance), 0)
        into accumulated_balance
        from movements
        where moment < NEW.moment;

    if new.movement_type then
        accumulated_balance := accumulated_balance + new.amount;
    else
        accumulated_balance := accumulated_balance - new.amount;
    end if;

    new.balance := accumulated_balance;
    return new;

end;
$$;


CREATE TRIGGER movement_record_the_balance
before INSERT ON movements
FOR EACH ROW
EXECUTE FUNCTION movements_record_the_balance();


-----

create view movements_with_balances_view as
   select * from movements_with_balances()
   -- select * from movements_with_balances(2024, '11')